{"version":3,"sources":["components/Navbar.js","components/Sidebar.js","scripts/imageRotation.js","components/ImagePanel.js","components/Content.js","App.js","index.js"],"names":["Navbar","className","Sidebar","props","useState","defaultFile","name","fileName","setFileName","width","setWidth","height","setHeight","angle","setAngle","canvasRef","useRef","canvas","setCanvas","initialized","setInitialized","useEffect","current","load","source","img","Image","src","onload","getContext","drawImage","imageData","getImageData","loadImageData","process","id","type","value","onClick","document","getElementById","click","accept","onChange","raw","window","FileReader","target","files","length","file","match","size","alert","reader","readAsDataURL","evt","readyState","DONE","result","console","log","hidden","ref","style","display","maxLength","e","tryRotate","htmlFor","checked","outlined","setOutlined","rotate","image","data","Error","radian","Math","PI","cosValue","abs","cos","sinValue","sin","newWidth","round","newHeight","newPixelArray","Uint8ClampedArray","offsetX","offsetY","originX","originY","y","x","destIdx","newPoint","rotatePoint","X","Y","currIdx","ImageData","xPrime","yPrime","util","Canvas","BackupData","Init","Clear","ReDraw","putImageData","Rotate","setRenderTime","setRotateAngle","ctx","start","performance","now","end","err","message","clearRect","Recall","ImagePanel","renderTime","rotateAngle","loadedImageData","rotated","setRotated","border","defaultFileInfo","Content","setLoadedImageData","parsed","parseInt","isNaN","Number","isInteger","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.59dfb9c3.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"styles/Navbar.css\";\r\n\r\nfunction Navbar() {\r\n  return (\r\n    <div className=\"navbar\">\r\n      <h2>Image Rotator</h2>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Navbar;\r\n","import React, { useState, useRef, useEffect } from \"react\";\r\nimport \"styles/Sidebar.css\";\r\n\r\n// 5 MegaByte Limit\r\nconst FILE_SIZE_LIMIT_MB = 5 * 1024;\r\n\r\nfunction Sidebar(props) {\r\n  const [fileName, setFileName] = useState(props.defaultFile.name);\r\n  const [width, setWidth] = useState(props.defaultFile.width);\r\n  const [height, setHeight] = useState(props.defaultFile.height);\r\n  const [angle, setAngle] = useState(0);\r\n  // we have to use a ref, which is a reference to the actual canvas DOM element.\r\n  const canvasRef = useRef(null);\r\n  const [canvas, setCanvas] = useState(null);\r\n  const [initialized, setInitialized] = useState(false);\r\n\r\n  useEffect(() => {\r\n    // Initialize Canvas State, this will be called only once\r\n    setCanvas(canvasRef.current);\r\n  }, []);\r\n\r\n  const triggerFileUpload = () => {\r\n    // reset previous file value to enable loading same file again and again\r\n    document.getElementById(\"imageLoader\").value = null;\r\n\r\n    // trigger input file to open file browser\r\n    document.getElementById(\"imageLoader\").click();\r\n  };\r\n\r\n  const tryToLoadImage = (raw) => {\r\n    // Safety Checks on File Load\r\n\r\n    // apparently not all browsers yet supports FileReader\r\n    if (!window.FileReader) {\r\n      alert(\"This browser does not support FileReader.\");\r\n      return;\r\n    }\r\n\r\n    if (!raw && raw.target.files.length === 0) {\r\n      // no file is selected, do nothing\r\n      console.log(\"no file is selected, do nothing\");\r\n      return;\r\n    }\r\n\r\n    let file = raw.target.files[0];\r\n\r\n    if (!file.type.match(\"image.*\")) {\r\n      alert(\"Only images are supported!\");\r\n      return;\r\n    }\r\n\r\n    if (file.size / 1024 > FILE_SIZE_LIMIT_MB) {\r\n      alert(\"Maximum allowed size: \" + FILE_SIZE_LIMIT_MB / 1024 + \" MB\");\r\n      return;\r\n    }\r\n\r\n    // then we have a valid image, load it!\r\n    let reader = new FileReader();\r\n    reader.readAsDataURL(file);\r\n    reader.onload = function (evt) {\r\n      if (evt.target.readyState === FileReader.DONE) {\r\n        load(evt.target.result);\r\n        setFileName(file.name);\r\n      }\r\n    };\r\n  };\r\n\r\n  // to load given file source as image\r\n  const load = (source) => {\r\n    if (source) {\r\n      let img = new Image();\r\n      img.src = source;\r\n      img.onload = function () {\r\n        // rearrange canvas size according to loaded image\r\n        canvas.width = img.width;\r\n        canvas.height = img.height;\r\n\r\n        // send loaded image's data file to upper component\r\n        canvas.getContext(\"2d\").drawImage(img, 0, 0);\r\n        const imageData = canvas\r\n          .getContext(\"2d\")\r\n          .getImageData(0, 0, canvas.width, canvas.height);\r\n        props.loadImageData(imageData);\r\n\r\n        // set data for file information area\r\n        setWidth(img.width);\r\n        setHeight(img.height);\r\n      };\r\n    }\r\n    // Else: invalid source, do nothing\r\n  };\r\n\r\n  const btnApplyOnClick = () => {\r\n    props.tryRotate(angle);\r\n  };\r\n\r\n  // set default image on initialization\r\n  if (!initialized && canvas) {\r\n    load(process.env.PUBLIC_URL + \"/default.png\");\r\n    setInitialized(true);\r\n  }\r\n\r\n  return (\r\n    <div className=\"sidebar\">\r\n      <div className=\"sideBarSectionTop\">\r\n        <input\r\n          id=\"uploadImageButton\"\r\n          className=\"btn btn-blue btn-large\"\r\n          type=\"button\"\r\n          value=\"Upload Image\"\r\n          onClick={triggerFileUpload}\r\n        />\r\n        <input\r\n          id=\"imageLoader\"\r\n          type=\"file\"\r\n          accept=\"image/*\"\r\n          onChange={tryToLoadImage}\r\n          hidden\r\n        />\r\n        <canvas ref={canvasRef} style={{ display: \"none\" }}></canvas>\r\n      </div>\r\n\r\n      <div className=\"horizontalBreak\"></div>\r\n\r\n      <div className=\"sideBarSectionMiddle\">\r\n        <div>\r\n          <span>\r\n            <b>File: </b>\r\n          </span>\r\n          <span>{fileName}</span>\r\n        </div>\r\n        <div>\r\n          <span>\r\n            <b>Width:</b>\r\n          </span>\r\n          <span>{width}</span>\r\n        </div>\r\n        <div>\r\n          <span>\r\n            <b>Height:</b>\r\n          </span>\r\n          <span>{height}</span>\r\n        </div>\r\n        <div>\r\n          <span>\r\n            <b>Rotate:</b>\r\n          </span>\r\n          <span>\r\n            <input\r\n              id=\"inputAngle\"\r\n              type=\"text\"\r\n              maxLength=\"4\"\r\n              size=\"2\"\r\n              onChange={(e) => setAngle(e.target.value)}\r\n            />\r\n            <input\r\n              type=\"button\"\r\n              className=\"btn btn-blue btn-small\"\r\n              value=\"Apply\"\r\n              onClick={btnApplyOnClick}\r\n            />\r\n          </span>\r\n        </div>\r\n        <div className=\"hoverPointer\">\r\n          {/* htmlFor instead of for thanks to React! */}\r\n          <label htmlFor=\"outlineCheckbox\">Outlined</label>\r\n          <input\r\n            type=\"checkbox\"\r\n            id=\"outlineCheckbox\"\r\n            checked={props.outlined}\r\n            onChange={(e) => props.setOutlined(e.target.checked)}\r\n          />\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Sidebar;\r\n","// Pixel Manipulation for a given ImageData\r\n\r\n/*\r\n * # Pixel manipulation reference from MDN\r\n *   https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas\r\n *\r\n * # ImageData creation\r\n *   give rotated image's width and height as second and third parameter, respectively.\r\n *   https://developer.mozilla.org/en-US/docs/Web/API/ImageData/ImageData\r\n *     array: Uint8ClampedArray\r\n *     width\r\n *     height\r\n *\r\n * # ImageData Pixel Indexing\r\n *   reaching to a point (pixel) in ImageData.data array:\r\n *     (x,y) = (col, row) --> index = (x + y * width) * 4 --> ImageData.data[index] (successive 4 index are belong to (x, y) in RGBA order)\r\n *\r\n * # Reference for Point Rotation\r\n *   Well Explained Point Rotation in 2D Coordinate System in regards to Origin (0,0) or (a,b)\r\n *   https://en.wikipedia.org/wiki/Rotation_(mathematics)\r\n *   https://en.wikipedia.org/wiki/Rotation_matrix\r\n *   https://stackoverflow.com/questions/2259476/rotating-a-point-about-another-point-2d\r\n *   https://developer.apple.com/ [Translation, Rotation, and Scaling: Rotation Around the Center]\r\n *\r\n *     theta:  given rotation angle\r\n \r\n *     Rotating P(x,y) around Origin (0,0):\r\n *     (x, y) -->  (x', y'):\r\n *       x' = x*cos(theta) - y*sin(theta)\r\n *       y' = x*sin(theta) + y*cos(theta)\r\n *\r\n *     Rotating around an Origin (a,b) other than default Origin (0,0)\r\n *     (x, y) -->  (x', y'):\r\n *       x' = ((x-a)*cos(theta) - (y-b)*sin(theta)) + a\r\n *       y' = ((x-a)*sin(theta) + (y-b)*cos(theta)) + b\r\n *\r\n *   x means column\r\n *   y means row\r\n */\r\n\r\n/*\r\n * Rotates given ImageData regarding given angle and image center\r\n * ImageData is built-in javascript object type with pixel array in it\r\n * Angle is in degree format\r\n * Approach: Point Rotation on 2D Coordinate System\r\n */\r\nfunction rotate(image, angle) {\r\n  // SAFETY CHECKS\r\n  // if given angle is 0 or 360 degree then do not rotate\r\n  if (angle % 360 === 0) {\r\n    return image;\r\n  }\r\n  // if given image pixel count is not equal to image.width*image.height then source data is corrupted\r\n  if (image.data.length / 4 !== image.width * image.height) {\r\n    throw new Error(\r\n      \"Provided image is corrupted. Length of pixel array is not consistent with image size!\"\r\n    );\r\n  }\r\n\r\n  // JS Math Library works with radian\r\n  let radian = convertToRadian(angle);\r\n\r\n  // find new size of image to be created\r\n  // see my drawing via sketchometry.org under ../public/Rotated Image Size Calculation.png\r\n  const cosValue = Math.abs(Math.cos(radian));\r\n  const sinValue = Math.abs(Math.sin(radian));\r\n  const newWidth = Math.round(image.width * cosValue + image.height * sinValue);\r\n  const newHeight = Math.round(image.height * cosValue + image.width * sinValue);\r\n  const newPixelArray = new Uint8ClampedArray(newWidth * newHeight * 4);\r\n\r\n  // offset should be calculated to translate newly created image to correct central position\r\n  // offset is simply half of the differences of both images sizes in both axis\r\n  const offsetX = Math.round((image.width - newWidth) / 2);\r\n  const offsetY = Math.round((image.height - newHeight) / 2);\r\n\r\n  // We need to rotate our image around center origin\r\n  // see comment section for details about rotation around a specific origin (a, b)\r\n  const originX = Math.round(newWidth / 2);\r\n  const originY = Math.round(newHeight / 2);\r\n\r\n  // O(M x N) time complexity where M, N are width and height of newly created image, respectively\r\n  for (let y = 0; y < newHeight; ++y) {\r\n    for (let x = 0; x < newWidth; ++x) {\r\n      // index calculation (refer to comment section: 'ImageData Pixel Indexing')\r\n      let destIdx = (x + y * newWidth) * 4;\r\n\r\n      // X-Prime and Y-Prime calculation (refer to comment section for details)\r\n      // Be careful about sign of radian. It is passed as negative since we are rotating from destination to source\r\n      let newPoint = rotatePoint(\r\n        x,\r\n        y,\r\n        originX,\r\n        originY,\r\n        -radian,\r\n        offsetX,\r\n        offsetY\r\n      );\r\n\r\n      // check if calculated new point is corresponds to any pixel on source image\r\n      let inRange =\r\n        newPoint.X >= 0 &&\r\n        newPoint.X < image.width &&\r\n        newPoint.Y >= 0 &&\r\n        newPoint.Y < image.height;\r\n\r\n      if (inRange) {\r\n        // copy from source to new image\r\n        let currIdx = (newPoint.X + newPoint.Y * image.width) * 4;\r\n        newPixelArray[destIdx + 0] = image.data[currIdx + 0];\r\n        newPixelArray[destIdx + 1] = image.data[currIdx + 1];\r\n        newPixelArray[destIdx + 2] = image.data[currIdx + 2];\r\n        newPixelArray[destIdx + 3] = image.data[currIdx + 3];\r\n      }\r\n      // Else: newPoint is out of range, ignore it\r\n    }\r\n  }\r\n\r\n  return new ImageData(newPixelArray, newWidth, newHeight);\r\n}\r\n\r\n/*\r\n * Rotate given point (x, y) according to given origin and radian degree\r\n * Rotating around an Origin (a,b)\r\n *     (x, y) -->  (x', y'):\r\n *       x' = ((x-a)*cos(theta) - (y-b)*sin(theta)) + a\r\n *       y' = ((x-a)*sin(theta) + (y-b)*cos(theta)) + b\r\n * offset (X,Y) are optional to translate position after rotation (like canvas.context.translate())\r\n */\r\nfunction rotatePoint(x, y, originX, originY, radian, offsetX = 0, offsetY = 0) {\r\n  let xPrime = (x - originX) * Math.cos(radian) - (y - originY) * Math.sin(radian) + originX;\r\n  let yPrime = (x - originX) * Math.sin(radian) + (y - originY) * Math.cos(radian) + originY;\r\n\r\n  // translate position if offsets are given\r\n  xPrime += offsetX;\r\n  yPrime += offsetY;\r\n\r\n  // round before set since we are working on 2D coordinate system and\r\n  // point positions are needed as integers to build array by indexing correct elements\r\n  // but as a side effect this is where we might use same source pixel in more than one place in our new image\r\n  // Interpolation would be a solution for this: nearest neighbor, bilinear, bicubic\r\n  return { X: Math.round(xPrime), Y: Math.round(yPrime) };\r\n}\r\n\r\n// Converts given degree to radian\r\nfunction convertToRadian(degree) {\r\n  return degree * (Math.PI / 180);\r\n}\r\n\r\nexport { rotate };\r\n","import React, { useEffect, useState, useRef } from \"react\";\r\nimport \"styles/ImagePanel.css\";\r\nimport { rotate } from \"scripts/imageRotation\";\r\n\r\n// ImagePanel is designed to work with ImageData Object as separated from other concerns\r\n\r\n// context.getImageData returns ImageData which is one-dimensional array\r\n// containing raw pixel data with RGBA format\r\n// ImageData\r\n//  .width\r\n//  .height\r\n//  .data : Uint8ClampedArray --> each pixel is represented by four one-byte values in RGBA format\r\n//                                data goes left to right then downward throughtout the array\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas\r\n\r\n// to read ImageData\r\n//    var myImageData = ctx.getImageData(left, top, width, height);\r\n\r\n// to write ImageData\r\n//    ctx.putImageData(myImageData, dx, dy);\r\n\r\n// to loop\r\n//    (var i = 0; i < data.length; i += 4)\r\n\r\nconst util = {\r\n  Canvas: null,\r\n  BackupData: null,\r\n  Init: (canvasRef) => {\r\n    util.Canvas = canvasRef;\r\n    util.Clear();\r\n  },\r\n  ReDraw: (imageData) => {\r\n    // imageData is an ImageData Object with three members; width, height, data\r\n    if (imageData) {\r\n      util.BackupData = imageData;\r\n      util.Clear();\r\n      util.Canvas.width = imageData.width;\r\n      util.Canvas.height = imageData.height;\r\n      const ctx = util.Canvas.getContext(\"2d\");\r\n      ctx.putImageData(imageData, 0, 0);\r\n    }\r\n    // Else: defensive - not expected to execute in normal run\r\n  },\r\n  Rotate: (angle, setRenderTime, setRotateAngle) => {\r\n    // to prevent repetitive rotation over already rotated image\r\n    // we will recall our originaly loaded image data on each request\r\n    const ctx = util.Canvas.getContext(\"2d\");\r\n    let data;\r\n    if (util.BackupData) {\r\n      data = util.BackupData;\r\n    } else {\r\n      data = ctx.getImageData(0, 0, util.Canvas.width, util.Canvas.height);\r\n    }\r\n\r\n    const start = performance.now();\r\n    let end = start;\r\n    try {\r\n      let result = rotate(data, angle);\r\n      end = performance.now();\r\n      util.Clear();\r\n      util.Canvas.width = result.width;\r\n      util.Canvas.height = result.height;\r\n      // last two parameters are paddings (start point(x,y) of image), give them as 0\r\n      ctx.putImageData(result, 0, 0);\r\n      setRenderTime(end - start);\r\n      setRotateAngle(angle);\r\n    } catch (err) {\r\n      alert(err.message);\r\n    }\r\n  },\r\n  Clear: () => {\r\n    // clear canvas\r\n    util.Canvas.getContext(\"2d\").clearRect(\r\n      0,\r\n      0,\r\n      util.Canvas.width,\r\n      util.Canvas.height\r\n    );\r\n  },\r\n  Recall: () => {\r\n    // recall our originaly loaded file, render canvas\r\n    if (util.BackupData) {\r\n      util.ReDraw(util.BackupData);\r\n    }\r\n  },\r\n};\r\n\r\nfunction ImagePanel(props) {\r\n  const [outlined, setOutlined] = useState(true);\r\n  const [renderTime, setRenderTime] = useState(0);\r\n  const [rotateAngle, setRotateAngle] = useState(0);\r\n  // we have to use a ref, which is a reference to the actual canvas DOM element.\r\n  const canvasRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    // Initialize Util.Canvas, this will be called only once\r\n    util.Init(canvasRef.current);\r\n  }, []);\r\n\r\n  // keep an eye on outlined property for border style of our canvas\r\n  useEffect(() => {\r\n    setOutlined(props.outlined);\r\n  }, [props.outlined]);\r\n\r\n  // Re-draw our newly loaded image\r\n  useEffect(() => {\r\n    util.ReDraw(props.loadedImageData);\r\n  }, [props.loadedImageData]);\r\n\r\n  useEffect(() => {\r\n    if (!props.rotated) {\r\n      util.Rotate(props.rotateAngle, setRenderTime, setRotateAngle);\r\n      props.setRotated(true);\r\n    }\r\n    // Else: angle received as invalid, do nothing\r\n  }, [props]);\r\n\r\n  return (\r\n    <div className=\"imageContainer\">\r\n      <canvas\r\n        id=\"myCanvas\"\r\n        ref={canvasRef}\r\n        style={{ border: outlined ? \"2px solid red\" : \"none\" }}\r\n      />\r\n      <div id=\"renderTime\">Rendered in: {renderTime} miliseconds</div>\r\n      <div id=\"roateDegree\">Rotated: {rotateAngle} degree</div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default ImagePanel;\r\n","import React, { useState } from \"react\";\r\nimport Sidebar from \"./Sidebar\";\r\nimport ImagePanel from \"./ImagePanel\";\r\nimport \"styles/Content.css\";\r\n\r\nconst defaultFileInfo = { name: \"default.png\", width: 440, height: 250 };\r\n\r\nfunction Content() {\r\n  const [outlined, setOutlined] = useState(true);\r\n  const [loadedImageData, setLoadedImageData] = useState(null);\r\n  const [rotateAngle, setRotateAngle] = useState(null);\r\n  const [rotated, setRotated] = useState(true);\r\n\r\n  // callback for rotate angle setting\r\n  const tryRotate = (angle) => {\r\n    let parsed = parseInt(angle);\r\n    if (!isNaN(parsed) && Number.isInteger(parsed)) {\r\n      setRotateAngle(parsed);\r\n      // reset rotated status so that image panel can handle rotation even if same angle is given\r\n      // so if we are not allowed to rotate over same angle then remove [rotated] state usage completely\r\n      setRotated(false);\r\n    } else {\r\n      alert(\"Given angle is not a valid number!\");\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"content\">\r\n      {/* this component will set loaded image */}\r\n      <Sidebar\r\n        loadImageData={setLoadedImageData}\r\n        defaultFile={defaultFileInfo}\r\n        tryRotate={tryRotate}\r\n        setOutlined={setOutlined}\r\n        outlined={outlined}\r\n      ></Sidebar>\r\n\r\n      {/* this component will use loaded image */}\r\n      <ImagePanel\r\n        loadedImageData={loadedImageData}\r\n        outlined={outlined}\r\n        rotateAngle={rotateAngle}\r\n        rotated={rotated}\r\n        setRotated={setRotated}\r\n      ></ImagePanel>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Content;\r\n","import \"./App.css\";\nimport Navbar from \"./components/Navbar\";\nimport Content from \"./components/Content\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Navbar></Navbar>\n      <Content></Content>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}